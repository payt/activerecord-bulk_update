# ActiveRecord BulkUpdate

Creates, updates or deletes multiple records in a single database statement.

### .bulk_create

Inserts multiple records into the database in a single query.

```ruby
users = [User.new(name: "foor"), User.new(name: "bar")]

User.where(active: true).bulk_create(users)
```

| Option  | Default | Description |
| ------------- | ------------- | ------------- |
| validate | true | when true it validates the records. |
| touch | true | when true it sets the created_at and updated_at timestamps. |
| ignore_persisted | false | when true it ignores any persisted records, when false it raises an exception. |

#### limitations
The main difference with the regular `create` method is that most callbacks are not triggered on the instances. `after_initialize` will have been triggered even before calling the bulk method. `before_validation` and `after_validation` will be triggered if `validate` is true. All other callbacks will not be triggered.

### .bulk_create!

see: [bulk_create](#bulk_create)

Except it raises an exception when any of the records are invalid.

### .bulk_delete

Deletes multiple records in a single delete query.

```ruby
users = User.where(id: [1, 2])

User.where(email: nil).bulk_delete(users)
```

### .bulk_delete_all

Combines multiple delete_all filters into a single delete query.

```ruby
filters = [{ email: nil }, { name: "y", country: [nil, "NL"] }]

User.where(active: false).bulk_delete_all(filters)
```

### .bulk_insert

Inserts multiple records into the database in a single query.

```ruby
users = [User.new(name: "foor"), User.new(name: "bar")]

User.where(active: true).bulk_insert(users, touch: true)
```

| Option  | Default | Description |
| ------------- | ------------- | ------------- |
| validate | false | when true it validates the records. |
| touch | false | when true it sets the created_at and updated_at timestamps. |
| ignore_persisted | false | when true it ignores any persisted records, when false it raises an exception. |

#### extras

- it assigns all default values generated by the database to the given instances, so no need to reload the instances.

### .bulk_update

```ruby
user1 = User.find(1)
user2 = User.find(2)

user1.name = "foo"
user2.email = "bar@example.com"

User.where(active: true).bulk_update([user1, user2], validate: false)
```

| Option  | Default | Description |
| ------------- | ------------- | ------------- |
| validate | true | when true it validates the records. |
| touch | true | when true it sets the updated_at timestamp. |

#### limitations
The main difference with the regular `update` method is that most callbacks are not triggered on the instances. `after_initialize` will have been triggered even before calling the bulk method. `before_validation` and `after_validation` will be triggered if `validate` is true. All other callbacks will not be triggered.

### .bulk_update!

see: [bulk_update](#bulk_update)

Except it raises an exception when any of the records are invalid.

### .bulk_update_columns

see: [bulk_update](#bulk_update)

Except the default values for the options are different.

| Option  | Default | Description |
| ------------- | ------------- | ------------- |
| validate | false | when true it validates the records. |
| touch | false | when true it sets the updated_at timestamp. |

### .bulk_update_all

```ruby
changes = {
  { country: "GB", locale: "en" } => { currency: "PND", is_eu: false, locale: "en-GB" },
  { country: "NL", locale: "nl" } => { currency: "EUR", is_eu: true, locale: "nl-NL" },
  { country: "US", locale: "en" } => { currency: "USD", is_eu: false, locale: "en-US" }
}

User.where(active: true).bulk_update_all(changes)
```

| Option  | Default | Description |
| ------------- | ------------- | ------------- |
| touch | false | when true it sets the updated_at timestamp. |

### How do the bulk update statements work

Constructs a single, efficient query to update multiple rows of a single table at once. Below you can find the SQL statement that is generated by the first examples in this readme.

```sql
UPDATE "users"
SET "name" = "source"."_name"
FROM (
  VALUES (
    CAST(1 AS integer), CAST('foo' AS character varying),
    (2, 'bar')
  )
) AS source(id, _name)
WHERE "source"."id" = "users"."id"
```

The code in this gem mirrors very closely the code used by methods like `update_all` and `insert_all`. It uses existing ActiveRecord classes and methods where-ever that is possible. This has the benefit that is behaves just as other ActiveRecord methods that you are used to, including raising the same type of exceptions and using the same logging.

### Limitations

- Only works for PostgreSQL
- Only works when all records belong to the same model, does not work with STI.
- Does not support optimistic locking.
- Does not support in_batches.

### TODO

- Add CI build for tests and linting!
- Auto-deploy to rubygems!
- Add bulk_destroy
- Add bulk_save
- Add the option to execute callbacks? Complex to implement and `around` callbacks are basically impossible.
- Improve performance when including a limit, order or offset clause in an update statement

### Testing

1. Create the test database: `CREATE DATABASE "activerecord-bulk_update_test";`
2. Run the tests: `bundle exec rake test`
